# Django ORM & SQL Mastery Cheat Sheet (0 to Hero)

## 🎯 Table of Contents
1. [Basic Query Builder](#basic-query-builder)
2. [Joins & Relationships](#joins--relationships)
3. [Raw SQL & Complex Queries](#raw-sql--complex-queries)
4. [Conditional Logic](#conditional-logic)
5. [Aggregations & Grouping](#aggregations--grouping)
6. [Union Queries](#union-queries)
7. [Advanced Techniques](#advanced-techniques)
8. [Performance & Optimization](#performance--optimization)
9. [Database Schema Checks](#database-schema-checks)
10. [Common Patterns](#common-patterns)

---

## 🚀 Basic Query Builder

### Simple Selects

```python
from django.db import models  # Import Django models
from myapp.models import User  # Import your model

# ═══════════════════════════════════════════════════
# BASIC QUERIES
# ═══════════════════════════════════════════════════

# Get all records (equivalent to DB::table('users')->get())
users = User.objects.all()  # Returns QuerySet of all users

# Get first record (equivalent to ->first())
user = User.objects.first()  # Returns first user or None

# Get by primary key (equivalent to ->find(1))
user = User.objects.get(pk=1)  # Returns user with ID=1 or raises DoesNotExist
# Or safer version
user = User.objects.filter(pk=1).first()  # Returns user or None

# ═══════════════════════════════════════════════════
# SELECT SPECIFIC COLUMNS
# ═══════════════════════════════════════════════════

# Method 1: only() - Returns model instances
users = User.objects.only('name', 'email')  # Loads only name and email fields
# Other fields are deferred (loaded on access)

# Method 2: values() - Returns dictionaries
users = User.objects.values('name', 'email')  # Returns list of dicts
# Result: [{'name': 'John', 'email': 'john@example.com'}, ...]

# Method 3: values_list() - Returns tuples
users = User.objects.values_list('name', 'email')  # Returns list of tuples
# Result: [('John', 'john@example.com'), ...]

# Flat list for single column
emails = User.objects.values_list('email', flat=True)  # Returns flat list
# Result: ['john@example.com', 'jane@example.com', ...]

# ═══════════════════════════════════════════════════
# WHERE CLAUSES
# ═══════════════════════════════════════════════════

# Simple where (equivalent to where('active', 1))
users = User.objects.filter(active=1)  # Get active users

# Greater than (equivalent to where('votes', '>', 100))
users = User.objects.filter(votes__gt=100)  # votes > 100
# __gt = greater than lookup

# Less than
users = User.objects.filter(votes__lt=100)  # votes < 100
# __lt = less than lookup

# Greater than or equal
users = User.objects.filter(votes__gte=100)  # votes >= 100
# __gte = greater than or equal lookup

# Less than or equal
users = User.objects.filter(votes__lte=100)  # votes <= 100
# __lte = less than or equal lookup

# Between (equivalent to whereBetween('votes', [1, 100]))
users = User.objects.filter(votes__range=(1, 100))  # 1 <= votes <= 100
# __range = between lookup (inclusive)

# In list (equivalent to whereIn('id', [1, 2, 3]))
users = User.objects.filter(id__in=[1, 2, 3])  # id IN (1, 2, 3)
# __in = IN lookup

# Not in list
users = User.objects.exclude(id__in=[1, 2, 3])  # id NOT IN (1, 2, 3)
# exclude() = NOT condition

# Is null (equivalent to whereNull('email_verified_at'))
users = User.objects.filter(email_verified_at__isnull=True)  # WHERE email_verified_at IS NULL
# __isnull=True = IS NULL

# Is not null
users = User.objects.filter(email_verified_at__isnull=False)  # WHERE email_verified_at IS NOT NULL
# __isnull=False = IS NOT NULL

# Like (case-sensitive)
users = User.objects.filter(name__contains='John')  # name LIKE '%John%'
# __contains = LIKE with wildcards

# Like (case-insensitive)
users = User.objects.filter(name__icontains='john')  # LOWER(name) LIKE LOWER('%john%')
# __icontains = case-insensitive LIKE

# Starts with
users = User.objects.filter(name__startswith='John')  # name LIKE 'John%'
# __startswith = starts with

# Ends with
users = User.objects.filter(name__endswith='Doe')  # name LIKE '%Doe'
# __endswith = ends with
```

### Date Filtering

```python
from django.utils import timezone  # Import timezone utilities
from datetime import datetime, timedelta  # Import datetime modules
import pytz  # For timezone handling

# ═══════════════════════════════════════════════════
# DATE FORMATTING & FILTERING
# ═══════════════════════════════════════════════════

# Parse and format dates (equivalent to Carbon in Laravel)
if start_date:  # If start_date provided
    start_date = datetime.strptime(start_date, '%Y/%m/%d')  # Parse string to datetime
    # strptime = string parse time
    start_date = timezone.make_aware(start_date)  # Make timezone-aware
    # Replace time with start of day
    start_date = start_date.replace(hour=0, minute=0, second=0, microsecond=0)

if end_date:  # If end_date provided
    end_date = datetime.strptime(end_date, '%Y/%m/%d')  # Parse string
    end_date = timezone.make_aware(end_date)  # Make timezone-aware
    # Replace time with end of day
    end_date = end_date.replace(hour=23, minute=59, second=59, microsecond=999999)

# Apply date range (equivalent to whereBetween('created_at', [$startDate, $endDate]))
orders = Order.objects.filter(
    created_at__range=(start_date, end_date)  # created_at BETWEEN start AND end
)
# __range = BETWEEN lookup (inclusive)

# Alternative: Using gte and lte
orders = Order.objects.filter(
    created_at__gte=start_date,  # created_at >= start_date
    created_at__lte=end_date     # created_at <= end_date
)

# ═══════════════════════════════════════════════════
# DATE LOOKUPS
# ═══════════════════════════════════════════════════

# Filter by year
orders = Order.objects.filter(created_at__year=2024)  # YEAR(created_at) = 2024
# __year = extract year

# Filter by month
orders = Order.objects.filter(created_at__month=12)  # MONTH(created_at) = 12
# __month = extract month

# Filter by day
orders = Order.objects.filter(created_at__day=25)  # DAY(created_at) = 25
# __day = extract day

# Filter by date (ignoring time)
today = timezone.now().date()  # Get today's date
orders = Order.objects.filter(created_at__date=today)  # DATE(created_at) = today
# __date = extract date part only

# Filter by week day
orders = Order.objects.filter(created_at__week_day=2)  # Day of week (1=Sunday, 2=Monday, etc.)
# __week_day = day of week

# Date greater than
orders = Order.objects.filter(created_at__gt=timezone.now())  # created_at > now
# __gt = greater than

# Date less than
orders = Order.objects.filter(created_at__lt=timezone.now())  # created_at < now
# __lt = less than

# Today's records
from django.utils import timezone
today_start = timezone.now().replace(hour=0, minute=0, second=0, microsecond=0)
today_end = timezone.now().replace(hour=23, minute=59, second=59, microsecond=999999)
orders = Order.objects.filter(created_at__range=(today_start, today_end))
```

---

## 🔗 Joins & Relationships

### Basic Joins

```python
from django.db.models import F, Q, Prefetch  # Import query tools

# ═══════════════════════════════════════════════════
# INNER JOIN (select_related for ForeignKey)
# ═══════════════════════════════════════════════════

# Equivalent to: DB::table('posts')->join('users', 'posts.user_id', '=', 'users.id')
posts = Post.objects.select_related('user').all()
# select_related = SQL INNER JOIN (for ForeignKey/OneToOne)
# Fetches related user data in single query with JOIN

# Access joined data
for post in posts:
    print(post.user.name)  # No additional query (already joined)

# ═══════════════════════════════════════════════════
# LEFT JOIN (select_related with nullable FK)
# ═══════════════════════════════════════════════════

# If ForeignKey is nullable (null=True), select_related does LEFT JOIN
posts = Post.objects.select_related('user').all()
# Automatically uses LEFT JOIN if user can be null

# ═══════════════════════════════════════════════════
# MULTIPLE JOINS
# ═══════════════════════════════════════════════════

# Join multiple tables (equivalent to multiple ->join())
posts = Post.objects.select_related('user', 'category').all()
# Joins both users and categories tables

# Nested joins using __ (double underscore)
comments = Comment.objects.select_related('post__user').all()
# Joins: comments -> posts -> users
# Access: comment.post.user.name

# ═══════════════════════════════════════════════════
# JOIN WITH CONDITIONS
# ═══════════════════════════════════════════════════

# Filter on joined table
posts = Post.objects.select_related('user').filter(user__active=True)
# JOIN users WHERE users.active = True
# user__ = access user table fields

# Multiple conditions on join
posts = Post.objects.select_related('user').filter(
    user__active=True,          # users.active = True
    user__votes__gt=100         # users.votes > 100
)

# ═══════════════════════════════════════════════════
# COMPLEX JOINS (using extra or raw)
# ═══════════════════════════════════════════════════

# Join with custom condition (equivalent to join with closure)
from django.db.models import Q

posts = Post.objects.select_related('user').filter(
    Q(user__active=True) & Q(published=True)  # Multiple conditions
)
# Q objects = complex query conditions
# & = AND, | = OR, ~ = NOT

# Manual join using extra (advanced)
posts = Post.objects.extra(
    tables=['users'],  # Additional table to join
    where=['posts.user_id = users.id', 'users.active = 1']  # Join conditions
)
```

### Complex Joins Examples

```python
# ═══════════════════════════════════════════════════
# JOIN WITH SPECIFIC FIELD CONDITIONS
# ═══════════════════════════════════════════════════

# Equivalent to Laravel's join with closure
# ->leftJoin('providers', function($join) {
#     $join->on('products.provider_name', '=', 'providers.id');
# })

# Django equivalent using select_related with filter
products = Product.objects.select_related('provider').filter(
    provider__id=F('provider_name')  # Join condition
)
# F() = reference to database field value

# ═══════════════════════════════════════════════════
# JOIN WITH RAW VALUE
# ═══════════════════════════════════════════════════

# Equivalent to: ->join("categories", function ($join) {
#     $join->on(DB::raw("5"), "=", "categories.id");
# })

from django.db.models import Value  # Import Value for literals

products = Product.objects.extra(
    where=["5 = categories.id"]  # Join with raw value
)

# Or using annotate
from django.db.models import Value, IntegerField

products = Product.objects.annotate(
    fixed_cat=Value(5, output_field=IntegerField())  # Add literal value
).filter(fixed_cat=F('category_id'))  # Use in filter

# ═══════════════════════════════════════════════════
# CONDITIONAL JOINS BASED ON FIELD VALUES
# ═══════════════════════════════════════════════════

# Equivalent to Laravel's conditional join
# ->leftJoin('bike_tables', function ($join) {
#     $join->on('orders.pkg_id', '=', 'bike_tables.id')
#          ->where('orders.insurance_type', '=', "'bike'");
# })

orders = Order.objects.select_related('bike_table').filter(
    insurance_type='bike',              # Condition on orders table
    bike_table__id=F('pkg_id')         # Join condition
)
# F('pkg_id') = reference to orders.pkg_id field
```

---

## 🎯 Raw SQL & Complex Queries

### Basic Raw Expressions

```python
from django.db.models import Count, Sum, Avg, F, Value, CharField  # Import aggregations
from django.db.models.functions import Concat, Coalesce, Cast  # Import SQL functions

# ═══════════════════════════════════════════════════
# BASIC RAW EXPRESSIONS
# ═══════════════════════════════════════════════════

# Count (equivalent to DB::raw("COUNT(*) as total"))
from django.db.models import Count
users = User.objects.annotate(post_count=Count('posts'))
# annotate = add calculated field
# Count('posts') = COUNT posts

# Sum (equivalent to DB::raw("SUM(amount) as total_amount"))
orders = Order.objects.aggregate(total_amount=Sum('amount'))
# aggregate = calculate single value
# Returns: {'total_amount': 1000}

# Concatenation (equivalent to DB::raw("CONCAT(first_name, ' ', last_name)"))
from django.db.models.functions import Concat
from django.db.models import Value, CharField

users = User.objects.annotate(
    full_name=Concat(
        'first_name',              # First field
        Value(' '),                # Space literal
        'last_name',               # Second field
        output_field=CharField()   # Result type
    )
)

# ═══════════════════════════════════════════════════
# RAW WHERE CLAUSES
# ═══════════════════════════════════════════════════

# Raw where (equivalent to ->whereRaw('age > ?', [25]))
users = User.objects.extra(where=['age > %s'], params=[25])
# extra = add raw SQL
# %s = parameter placeholder

# Raw where with function (equivalent to ->whereRaw('YEAR(created_at) = ?', [2024]))
orders = Order.objects.extra(
    where=['YEAR(created_at) = %s'],  # Raw SQL condition
    params=[2024]                      # Parameters
)

# Better way: using __year lookup
orders = Order.objects.filter(created_at__year=2024)
# __year = extract year from date
```

### Advanced Raw Queries

```python
from django.db import connection  # Import database connection

# ═══════════════════════════════════════════════════
# SAFE COLUMN EXISTENCE CHECK
# ═══════════════════════════════════════════════════

# Equivalent to Laravel's column existence check
# DB::raw("COALESCE(CASE WHEN EXISTS (
#     SELECT 1 FROM information_schema.columns
#     WHERE table_name = 'orders' AND column_name = 'due_payment'
# ) THEN orders.due_payment ELSE 0 END, 0) as due_amount")

from django.db.models import Case, When, Value, F, Q
from django.db.models.functions import Coalesce

# Check if column exists before query
def column_exists(table_name, column_name):
    """Check if column exists in table"""
    with connection.cursor() as cursor:  # Get database cursor
        cursor.execute("""
            SELECT 1 FROM information_schema.columns
            WHERE table_schema = DATABASE()
            AND table_name = %s
            AND column_name = %s
        """, [table_name, column_name])  # Execute with parameters
        return cursor.fetchone() is not None  # Return True if exists

# Use in query
if column_exists('orders', 'due_payment'):  # Check if column exists
    orders = Order.objects.annotate(
        due_amount=Coalesce('due_payment', Value(0))  # Use column if exists
    )
else:
    orders = Order.objects.annotate(
        due_amount=Value(0)  # Default value if not exists
    )

# ═══════════════════════════════════════════════════
# CHARACTER SET HANDLING
# ═══════════════════════════════════════════════════

# Equivalent to: CAST(COALESCE(name, 'Default') AS CHAR CHARACTER SET utf8mb4)
from django.db.models.functions import Cast, Coalesce
from django.db.models import CharField, Value

dealers = Dealer.objects.annotate(
    sold_by=Cast(
        Coalesce('com_org_inst_name', Value('Instasure')),  # NULL handling
        output_field=CharField()  # Cast to string
    )
)
# Coalesce = return first non-null value
# Cast = convert data type

# ═══════════════════════════════════════════════════
# JSON EXTRACTION
# ═══════════════════════════════════════════════════

# Django supports JSONField natively
from django.db.models import JSONField

# Model definition
class DeviceInsurance(models.Model):
    customer_info = models.JSONField()  # JSON field

# Extract from JSON (equivalent to JSON_EXTRACT)
insurances = DeviceInsurance.objects.annotate(
    customer_name=F('customer_info__customer_name')  # Access JSON field
)
# customer_info__customer_name = access nested JSON

# JSON conditions (equivalent to whereRaw with JSON_EXTRACT)
insurances = DeviceInsurance.objects.filter(
    customer_info__customer_name='John'  # Filter by JSON field
)

# For PostgreSQL JSON operations
from django.contrib.postgres.fields import JSONField  # PostgreSQL-specific
from django.db.models import Q

orders = TravelOrder.objects.filter(
    payment_details__pgw_name='PayPal'  # Access nested JSON
)
# payment_details__pgw_name = payment_details['pgw_name']

# Coalesce with JSON extraction
orders = TravelOrder.objects.annotate(
    payment_method=Coalesce(
        F('payment_details__pgw_name'),  # Try JSON field
        Value('Instasure')               # Default value
    )
)

# ═══════════════════════════════════════════════════
# COMPLETELY RAW SQL
# ═══════════════════════════════════════════════════

# Execute completely raw SQL
from django.db import connection

def get_custom_report():
    with connection.cursor() as cursor:  # Get cursor
        cursor.execute("""
            SELECT 
                o.id,
                o.order_ref,
                COALESCE(u.name, 'Guest') as customer_name,
                CASE
                    WHEN o.status = 1 THEN 'Active'
                    WHEN o.status = 0 THEN 'Inactive'
                    ELSE 'Unknown'
                END as status_label
            FROM orders o
            LEFT JOIN users u ON o.user_id = u.id
            WHERE o.created_at >= %s
        """, [start_date])  # Pass parameters
        
        columns = [col[0] for col in cursor.description]  # Get column names
        results = [
            dict(zip(columns, row))  # Convert to dict
            for row in cursor.fetchall()  # Fetch all rows
        ]
    return results

# Or use raw() for model instances
orders = Order.objects.raw(
    'SELECT * FROM orders WHERE status = %s',  # Raw SQL
    [1]  # Parameters
)
# Returns model instances
```

---

## 🔄 Conditional Logic

### CASE Statements

```python
from django.db.models import Case, When, Value, F, Q, CharField  # Import CASE tools

# ═══════════════════════════════════════════════════
# SIMPLE CASE STATEMENT
# ═══════════════════════════════════════════════════

# Equivalent to:
# CASE 
#     WHEN status = 'active' THEN 'Active User'
#     WHEN status = 'inactive' THEN 'Inactive User'
#     ELSE 'Unknown'
# END

users = User.objects.annotate(
    status_label=Case(  # CASE statement
        When(status='active', then=Value('Active User')),    # WHEN condition
        When(status='inactive', then=Value('Inactive User')),  # WHEN condition
        default=Value('Unknown'),  # ELSE clause
        output_field=CharField()   # Result data type
    )
)
# Case = CASE statement
# When = WHEN condition
# then = THEN value
# default = ELSE value

# Access result
for user in users:
    print(user.status_label)  # 'Active User', 'Inactive User', or 'Unknown'

# ═══════════════════════════════════════════════════
# COMPLEX CASE STATEMENT
# ═══════════════════════════════════════════════════

# Equivalent to Laravel's complex CASE:
# CASE
#     WHEN COALESCE(order_parents.total_payment, 0) > 0
#     THEN COALESCE(order_parents.total_payment, 0)
#     
#     WHEN COALESCE(child_orders.total_payment, 0) > 0
#     THEN COALESCE(child_orders.total_payment, 0)
#     
#     ELSE COALESCE(child_orders.due_payment, 0)
# END

from django.db.models.functions import Coalesce

orders = Order.objects.annotate(
    total_payment=Case(
        When(
            Q(parent__total_payment__gt=0),  # First condition
            then=Coalesce('parent__total_payment', Value(0))  # First result
        ),
        When(
            Q(child__total_payment__gt=0),  # Second condition
            then=Coalesce('child__total_payment', Value(0))  # Second result
        ),
        default=Coalesce('child__due_payment', Value(0)),  # Default
        output_field=models.DecimalField()  # Result type
    )
)
# Q() = complex query condition
# Coalesce = return first non-null value

# ═══════════════════════════════════════════════════
# CASE WITH MULTIPLE CONDITIONS
# ═══════════════════════════════════════════════════

orders = Order.objects.annotate(
    priority=Case(
        When(
            Q(amount__gte=1000) & Q(status='urgent'),  # Multiple conditions with AND
            then=Value('High')
        ),
        When(
            Q(amount__gte=500) | Q(status='important'),  # Multiple conditions with OR
            then=Value('Medium')
        ),
        default=Value('Low'),
        output_field=CharField()
    )
)
# & = AND
# | = OR
# ~ = NOT

# ═══════════════════════════════════════════════════
# CASE WITH FIELD COMPARISONS
# ═══════════════════════════════════════════════════

products = Product.objects.annotate(
    stock_status=Case(
        When(stock__lte=F('reorder_level'), then=Value('Low Stock')),  # Compare fields
        When(stock__gte=F('max_stock'), then=Value('Overstock')),
        default=Value('Normal'),
        output_field=CharField()
    )
)
# F('field_name') = reference to field value
# Compare stock with reorder_level field
```

### Conditional WHERE Clauses

```python
from django.db.models import Q  # Import Q for complex queries

# ═══════════════════════════════════════════════════
# MULTIPLE OR CONDITIONS
# ═══════════════════════════════════════════════════

# Equivalent to Laravel:
# if ($provider) {
#     $query->where(function ($q) use ($provider) {
#         $q->where('providers.id', '=', $provider)
#           ->orWhere('products.provider_name', '=', $provider);
#     });
# }

# Django equivalent
query = Product.objects.all()  # Start with all products

if provider:  # If provider filter provided
    query = query.filter(
        Q(provider__id=provider) | Q(provider_name=provider)  # OR condition
    )
    # Q() = complex query object
    # | = OR operator
    # & = AND operator
    # ~ = NOT operator

# ═══════════════════════════════════════════════════
# DYNAMIC FILTERING
# ═══════════════════════════════════════════════════

# Build query dynamically based on parameters
orders = Order.objects.all()  # Start with all orders

if payment_method:  # If payment method filter provided
    orders = orders.filter(pgw_name=payment_method)  # Add filter

if parent_dealer:  # If parent dealer filter provided
    orders = orders.filter(dealer__parent_id=parent_dealer)  # Add filter

if status:  # If status filter provided
    orders = orders.filter(status=status)  # Add filter

# All filters are combined with AND automatically

# ═══════════════════════════════════════════════════
# COMPLEX CONDITIONAL QUERIES
# ═══════════════════════════════════════════════════

def build_dynamic_query(filters):
    """Build query based on multiple filter conditions"""
    query = Order.objects.all()  # Base query
    
    # Date range filter
    if filters.get('start_date') and filters.get('end_date'):
        query = query.filter(
            created_at__range=(filters['start_date'], filters['end_date'])
        )
    
    # Provider filter with OR
    if filters.get('provider'):
        query = query.filter(
            Q(provider__id=filters['provider']) | 
            Q(provider_name=filters['provider'])
        )
    
    # Status filter
    if filters.get('status'):
        query = query.filter(status=filters['status'])
    
    # Amount range
    if filters.get('min_amount'):
        query = query.filter(amount__gte=filters['min_amount'])
    
    if filters.get('max_amount'):
        query = query.filter(amount__lte=filters['max_amount'])
    
    return query  # Return built query

# ═══════════════════════════════════════════════════
# EXCLUDE (NOT) CONDITIONS
# ═══════════════════════════════════════════════════

# Get orders NOT in specific statuses
orders = Order.objects.exclude(status__in=['cancelled', 'refunded'])
# exclude() = NOT condition

# Exclude with OR
orders = Order.objects.exclude(
    Q(status='cancelled') | Q(amount=0)
)

# Exclude with AND
orders = Order.objects.exclude(
    Q(status='cancelled') & Q(amount=0)
)
```

---

## 📊 Aggregations & Grouping

### Basic Aggregations

```python
from django.db.models import Count, Sum, Avg, Max, Min, F  # Import aggregation functions
from django.db.models.functions import Coalesce  # Import SQL functions

# ═══════════════════════════════════════════════════
# SINGLE VALUE AGGREGATIONS (aggregate)
# ═══════════════════════════════════════════════════

# Count (equivalent to DB::table('orders')->count())
total_orders = Order.objects.count()  # Returns integer: 100
# count() = COUNT(*)

# Sum (equivalent to ->sum('amount'))
total_amount = Order.objects.aggregate(total=Sum('amount'))
# aggregate() = return single calculated value
# Returns dict: {'total': 5000}

# Average (equivalent to ->avg('amount'))
avg_amount = Order.objects.aggregate(average=Avg('amount'))
# Returns: {'average': 250.50}

# Maximum (equivalent to ->max('amount'))
max_amount = Order.objects.aggregate(maximum=Max('amount'))
# Returns: {'maximum': 1000}

# Minimum (equivalent to ->min('amount'))
min_amount = Order.objects.aggregate(minimum=Min('amount'))
# Returns: {'minimum': 50}

# Multiple aggregations at once
stats = Order.objects.aggregate(
    total_orders=Count('id'),      # Count orders
    total_amount=Sum('amount'),    # Sum amounts
    avg_amount=Avg('amount'),      # Average amount
    max_amount=Max('amount'),      # Maximum amount
    min_amount=Min('amount')       # Minimum amount
)
# Returns: {
#     'total_orders': 100,
#     'total_amount': 5000,
#     'avg_amount': 250.50,
#     'max_amount': 1000,
#     'min_amount': 50
# }

# ═══════════════════════════════════════════════════
# PER-OBJECT AGGREGATIONS (annotate)
# ═══════════════════════════════════════════════════

# Count related objects for each user
users = User.objects.annotate(post_count=Count('posts'))
# annotate() = add calculated field to each object
# Each user gets post_count field

# Access annotated field
for user in users:
    print(f"{user.name} has {user.post_count} posts")

# Multiple annotations
users = User.objects.annotate(
    post_count=Count('posts'),           # Count posts
    total_votes=Sum('posts__votes'),     # Sum votes across posts
    avg_votes=Avg('posts__votes')        # Average votes per post
)
# posts__votes = access votes through posts relationship

# ═══════════════════════════════════════════════════
# GROUP BY
# ═══════════════════════════════════════════════════

# Equivalent to:
# SELECT status, COUNT(*) as count
# FROM orders
# GROUP BY status

from django.db.models import Count

order_stats = Order.objects.values('status').annotate(
    count=Count('id')  # Count per status
)
# values('status') = GROUP BY status
# annotate(count=Count('id')) = COUNT(id)

# Returns: [
#     {'status': 'pending', 'count': 10},
#     {'status': 'completed', 'count': 50},
#     {'status': 'cancelled', 'count': 5}
# ]

# Group by multiple fields
stats = Order.objects.values('status', 'payment_method').annotate(
    count=Count('id'),           # Count orders
    total=Sum('amount')          # Sum amounts
)
# GROUP BY status, payment_method

# ═══════════════════════════════════════════════════
# GROUP BY WITH HAVING
# ═══════════════════════════════════════════════════

# Get users with more than 5 posts
users = User.objects.annotate(
    post_count=Count('posts')  # Add count
).filter(
    post_count__gt=5  # Filter after grouping (HAVING)
)
# filter() after annotate() = HAVING clause

# Complex having conditions
users = User.objects.annotate(
    post_count=Count('posts'),
    total_votes=Sum('posts__votes')
).filter(
    post_count__gte=5,      # HAVING post_count >= 5
    total_votes__gte=100    # AND total_votes >= 100
)
```

### Complex Calculations

```python
from django.db.models import F, ExpressionWrapper, DecimalField  # Import calculation tools
from django.db.models.functions import Coalesce  # Import functions

# ═══════════════════════════════════════════════════
# REVENUE CALCULATION
# ═══════════════════════════════════════════════════

# Equivalent to Laravel:
# $vatAmount = ($order->total_amount * $order->vat) / 100;
# $revenue = $order->total_amount - $vatAmount - $order->commission - $order->provider_amount;

orders = Order.objects.annotate(
    # Calculate VAT amount
    vat_amount=ExpressionWrapper(
        F('total_amount') * F('vat') / 100,  # (total_amount * vat) / 100
        output_field=DecimalField(max_digits=10, decimal_places=2)  # Result type
    ),
    # Calculate revenue
    revenue=ExpressionWrapper(
        F('total_amount') -                           # Start with total
        (F('total_amount') * F('vat') / 100) -       # Subtract VAT
        F('commission') -                             # Subtract commission
        Coalesce(F('provider_amount'), Value(0)),    # Subtract provider amount (default 0)
        output_field=DecimalField(max_digits=10, decimal_places=2)  # Result type
    )
)
# F('field') = reference to field value
# ExpressionWrapper = wrap complex expression with output type
# Coalesce = NULL handling

# Access calculated fields
for order in orders:
    print(f"Revenue: {order.revenue}")

# ═══════════════════════════════════════════════════
# IN-QUERY CALCULATIONS
# ═══════════════════════════════════════════════════

# Equivalent to:
# DB::raw("(total_amount - (total_amount * vat / 100) - commission - provider_amount) as revenue")

from django.db.models import F, DecimalField

orders = Order.objects.annotate(
    net_revenue=ExpressionWrapper(
        (F('total_amount') - 
         (F('total_amount') * F('vat') / 100) - 
         F('commission') - 
         F('provider_amount')),
        output_field=DecimalField(max_digits=10, decimal_places=2)
    )
)

# ═══════════════════════════════════════════════════
# PERCENTAGE CALCULATIONS
# ═══════════════════════════════════════════════════

products = Product.objects.annotate(
    # Calculate discount percentage
    discount_percent=ExpressionWrapper(
        (F('original_price') - F('sale_price')) / F('original_price') * 100,
        output_field=DecimalField(max_digits=5, decimal_places=2)
    ),
    # Calculate profit margin
    profit_margin=ExpressionWrapper(
        (F('sale_price') - F('cost_price')) / F('sale_price') * 100,
        output_field=DecimalField(max_digits=5, decimal_places=2)
    )
)

# ═══════════════════════════════════════════════════
# FIELD COMPARISONS
# ═══════════════════════════════════════════════════

# Find products where stock is below reorder level
products = Product.objects.annotate(
    needs_reorder=Case(
        When(stock__lt=F('reorder_level'), then=Value(True)),  # Compare fields
        default=Value(False),
        output_field=models.BooleanField()
    )
).filter(needs_reorder=True)

# Calculate difference between fields
orders = Order.objects.annotate(
    amount_diff=F('total_amount') - F('paid_amount')  # Difference
).filter(amount_diff__gt=0)  # Filter where difference > 0
```

---

## 🔗 Union Queries

### Basic Union

```python
from django.db.models import QuerySet  # Import QuerySet

# ═══════════════════════════════════════════════════
# SIMPLE UNION
# ═══════════════════════════════════════════════════

# Equivalent to Laravel:
# $first = DB::table('users')->where('active', 1);
# $second = DB::table('users')->where('premium', 1);
# $users = $first->union($second)->get();

# Get active users
active_users = User.objects.filter(active=True)  # First query

# Get premium users
premium_users = User.objects.filter(premium=True)  # Second query

# Combine with union
all_users = active_users.union(premium_users)  # UNION (removes duplicates)
# union() = SQL UNION (removes duplicates)

# UNION ALL (keeps duplicates)
all_users = active_users.union(premium_users, all=True)  # UNION ALL
# all=True = keep duplicates

# ═══════════════════════════════════════════════════
# UNION WITH DIFFERENT MODELS (Same structure)
# ═══════════════════════════════════════════════════

# Both queries must return same fields
posts = Post.objects.values('id', 'title', 'created_at')  # Select specific fields
articles = Article.objects.values('id', 'title', 'created_at')  # Same fields

combined = posts.union(articles)  # Combine results
# Both must have same number and type of fields

# ═══════════════════════════════════════════════════
# MULTIPLE UNIONS
# ═══════════════════════════════════════════════════

query1 = User.objects.filter(active=True).values('id', 'name', 'email')
query2 = User.objects.filter(premium=True).values('id', 'name', 'email')
query3 = User.objects.filter(verified=True).values('id', 'name', 'email')

# Chain multiple unions
result = query1.union(query2).union(query3)  # Multiple unions
# Removes duplicates across all queries

# ═══════════════════════════════════════════════════
# UNION WITH ORDER BY
# ═══════════════════════════════════════════════════

active = User.objects.filter(active=True).values('id', 'name', 'created_at')
premium = User.objects.filter(premium=True).values('id', 'name', 'created_at')

# Union and order
result = active.union(premium).order_by('-created_at')  # Order after union
# Order must be on final result
```

### Complex Union Pattern

```python
# ═══════════════════════════════════════════════════
# COMPLEX UNION FROM DIFFERENT SOURCES
# ═══════════════════════════════════════════════════

# Equivalent to Laravel's multiple query union pattern
def build_report(categories_to_include):
    """Build report combining multiple categories"""
    queries = []  # List to hold queries
    
    # ───────────────────────────────────────────────
    # Life & Health Orders (Category 8)
    # ───────────────────────────────────────────────
    if 8 in categories_to_include:
        life_health_query = Order.objects.filter(
            category_id=8  # Filter by category
        ).select_related(
            'dealer', 'provider'  # Join related tables
        ).annotate(
            # Add calculated fields
            customer_name=F('customer__name'),
            provider_name=F('provider__name'),
            sold_by=F('dealer__name'),
            payment_method=F('pgw_name'),
            # More annotations...
        ).values(  # Select specific fields for union
            'id', 'order_ref_id', 'customer_name', 'provider_name',
            'sold_by', 'payment_method', 'total_amount'
        )
        queries.append(life_health_query)  # Add to queries list
    
    # ───────────────────────────────────────────────
    # Travel Insurance (Category 5)
    # ───────────────────────────────────────────────
    if 5 in categories_to_include:
        travel_query = TravelOrder.objects.filter(
            category_id=5
        ).annotate(
            # Extract from JSON field
            customer_name=F('travel_info__customer_name'),
            # More annotations...
        ).values(
            'id', 'order_ref_id', 'customer_name', 'provider_name',
            'sold_by', 'payment_method', 'total_amount'
        )
        queries.append(travel_query)  # Add to queries list
    
    # ───────────────────────────────────────────────
    # Motor Insurance (Category 6)
    # ───────────────────────────────────────────────
    if 6 in categories_to_include:
        motor_query = MotorOrder.objects.filter(
            category_id=6
        ).annotate(
            customer_name=F('owner_name'),
            # More annotations...
        ).values(
            'id', 'order_ref_id', 'customer_name', 'provider_name',
            'sold_by', 'payment_method', 'total_amount'
        )
        queries.append(motor_query)  # Add to queries list
    
    # ───────────────────────────────────────────────
    # Combine all queries with union
    # ───────────────────────────────────────────────
    if not queries:  # If no queries
        return []  # Return empty list
    
    # Start with first query
    final_query = queries[0]
    
    # Union with remaining queries
    for query in queries[1:]:  # Loop through remaining queries
        final_query = final_query.union(query)  # Add union
    
    # Order final result
    return final_query.order_by('-id')  # Order by ID descending

# Usage
categories = [5, 6, 8]  # Categories to include
report_data = build_report(categories)  # Get combined data
```

---

## 🚀 Advanced Techniques

### Dynamic Query Building

```python
from django.db.models import Q  # Import Q for complex conditions

# ═══════════════════════════════════════════════════
# DYNAMIC QUERY BUILDER
# ═══════════════════════════════════════════════════

def build_dynamic_query(filters=None):
    """
    Build query dynamically based on filters
    
    Args:
        filters (dict): Dictionary of filter parameters
        
    Returns:
        QuerySet: Filtered queryset
    """
    if filters is None:
        filters = {}  # Default empty dict
    
    query = Order.objects.all()  # Start with all orders
    
    # ───────────────────────────────────────────────
    # Dynamic category inclusion
    # ───────────────────────────────────────────────
    categories_to_include = []
    
    if filters.get('category') == 100:  # All Reports
        categories_to_include = [5, 6, 8, 10, 11, 12, 16, 17, 18, 20, 21]
    elif filters.get('category') == 7:  # Dealer
        categories_to_include = [5, 6, 8, 10, 11, 12, 16, 17, 18, 20, 21]
    elif filters.get('category'):  # Specific category
        categories_to_include = [filters['category']]
    
    if categories_to_include:  # If categories specified
        query = query.filter(category_id__in=categories_to_include)
    
    # ───────────────────────────────────────────────
    # Date range filter
    # ───────────────────────────────────────────────
    if filters.get('start_date') and filters.get('end_date'):
        query = query.filter(
            created_at__range=(filters['start_date'], filters['end_date'])
        )
    
    # ───────────────────────────────────────────────
    # Provider filter
    # ───────────────────────────────────────────────
    if filters.get('provider'):
        query = query.filter(
            Q(provider__id=filters['provider']) |
            Q(provider_name=filters['provider'])
        )
    
    # ───────────────────────────────────────────────
    # Status filter
    # ───────────────────────────────────────────────
    if filters.get('status'):
        query = query.filter(status=filters['status'])
    
    # ───────────────────────────────────────────────
    # Payment method filter
    # ───────────────────────────────────────────────
    if filters.get('payment_method'):
        query = query.filter(pgw_name=filters['payment_method'])
    
    # ───────────────────────────────────────────────
    # Dealer filter
    # ───────────────────────────────────────────────
    if filters.get('dealer'):
        query = query.filter(dealer_id=filters['dealer'])
    
    return query  # Return built query

# Usage
filters = {
    'category': 8,
    'start_date': '2024-01-01',
    'end_date': '2024-12-31',
    'provider': 5,
    'status': 'completed'
}
orders = build_dynamic_query(filters)  # Get filtered orders
```

### Subqueries

```python
from django.db.models import Subquery, OuterRef, Exists  # Import subquery tools

# ═══════════════════════════════════════════════════
# SUBQUERY IN SELECT (annotate)
# ═══════════════════════════════════════════════════

# Equivalent to:
# SELECT users.*, (
#     SELECT COUNT(*) FROM posts WHERE posts.user_id = users.id
# ) as post_count
# FROM users

# Method 1: Using subquery
from django.db.models import Count, Subquery, OuterRef

# Define subquery
post_count_subquery = Post.objects.filter(
    user_id=OuterRef('pk')  # Reference to outer query's id
).values('user_id').annotate(
    count=Count('id')  # Count posts
).values('count')  # Return only count

# Use subquery in annotation
users = User.objects.annotate(
    post_count=Subquery(post_count_subquery)  # Add subquery result
)
# OuterRef('pk') = reference to outer query's primary key
# Subquery() = execute as subquery

# Method 2: Using Count (simpler for this case)
users = User.objects.annotate(
    post_count=Count('posts')  # Django handles subquery
)

# ═══════════════════════════════════════════════════
# EXISTS SUBQUERY
# ═══════════════════════════════════════════════════

# Equivalent to:
# SELECT * FROM users
# WHERE EXISTS (
#     SELECT 1 FROM orders WHERE orders.user_id = users.id
# )

from django.db.models import Exists, OuterRef

# Define exists subquery
has_orders = Order.objects.filter(
    user_id=OuterRef('pk')  # Reference to outer query
)

# Use exists in filter
users = User.objects.annotate(
    has_orders=Exists(has_orders)  # Add boolean field
).filter(has_orders=True)  # Filter where exists
# Exists() = SQL EXISTS clause

# Or simpler version
users = User.objects.filter(orders__isnull=False).distinct()
# Filter users who have at least one order

# ═══════════════════════════════════════════════════
# SUBQUERY WITH LATEST VALUE
# ═══════════════════════════════════════════════════

# Get users with their latest order date
latest_order = Order.objects.filter(
    user_id=OuterRef('pk')  # Link to user
).order_by('-created_at')  # Order by date descending

users = User.objects.annotate(
    latest_order_date=Subquery(
        latest_order.values('created_at')[:1]  # Get first result
    )
)
# [:1] = LIMIT 1

# ═══════════════════════════════════════════════════
# SUBQUERY IN FILTER
# ═══════════════════════════════════════════════════

# Get orders with amount greater than user's average
avg_amount_subquery = Order.objects.filter(
    user_id=OuterRef('user_id')  # Link to same user
).values('user_id').annotate(
    avg=Avg('amount')  # Calculate average
).values('avg')

expensive_orders = Order.objects.annotate(
    user_avg=Subquery(avg_amount_subquery)  # Add average
).filter(
    amount__gt=F('user_avg')  # Compare with average
)
# F('user_avg') = reference to annotated field

# ═══════════════════════════════════════════════════
# COMPLEX SUBQUERY WITH AGGREGATION
# ═══════════════════════════════════════════════════

# Get categories with their total order count
order_count_subquery = Order.objects.filter(
    category_id=OuterRef('pk')  # Link to category
).values('category_id').annotate(
    total=Count('id')  # Count orders
).values('total')

categories = Category.objects.annotate(
    order_count=Subquery(order_count_subquery),  # Add count
    active_order_count=Subquery(  # Another subquery
        Order.objects.filter(
            category_id=OuterRef('pk'),
            status='active'
        ).values('category_id').annotate(
            total=Count('id')
        ).values('total')
    )
)
```

---

## ⚡ Performance & Optimization

### Indexing Strategy

```python
from django.db import models  # Import models module

# ═══════════════════════════════════════════════════
# CREATE INDEXES IN MODELS
# ═══════════════════════════════════════════════════

class Order(models.Model):
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        db_index=True  # Create index on foreign key
    )
    status = models.CharField(
        max_length=20,
        db_index=True  # Create index on status
    )
    created_at = models.DateTimeField(
        auto_now_add=True,
        db_index=True  # Create index on date
    )
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    
    class Meta:
        # Composite index (multiple columns)
        indexes = [
            models.Index(fields=['status', 'created_at']),  # Index on both
            models.Index(fields=['user', 'status']),         # Another composite
            models.Index(fields=['-created_at']),            # Descending index
        ]
        # Name indexes for clarity
        indexes = [
            models.Index(
                fields=['status', 'created_at'],
                name='order_status_date_idx'  # Custom index name
            ),
        ]

# ═══════════════════════════════════════════════════
# CREATE INDEXES IN MIGRATIONS
# ═══════════════════════════════════════════════════

# In migration file
from django.db import migrations, models

class Migration(migrations.Migration):
    dependencies = [
        ('myapp', '0001_initial'),
    ]
    
    operations = [
        # Add single column index
        migrations.AddIndex(
            model_name='order',
            index=models.Index(fields=['user_id'], name='order_user_idx'),
        ),
        # Add composite index
        migrations.AddIndex(
            model_name='order',
            index=models.Index(
                fields=['status', 'created_at'],
                name='order_status_date_idx'
            ),
        ),
    ]
```

### Query Optimization Tips

```python
# ═══════════════════════════════════════════════════
# 1. SELECT SPECIFIC COLUMNS
# ═══════════════════════════════════════════════════

# Bad: Select all columns
users = User.objects.all()  # SELECT * FROM users

# Good: Select only needed columns
users = User.objects.only('id', 'name', 'email')  # SELECT id, name, email
# only() = load only specified fields

# Or use values() for dictionaries
users = User.objects.values('id', 'name', 'email')  # Returns dicts
# values() = return dictionaries instead of model instances

# ═══════════════════════════════════════════════════
# 2. LIMIT RESULTS
# ═══════════════════════════════════════════════════

# Get first 100 records
users = User.objects.all()[:100]  # LIMIT 100
# [:100] = slice to limit

# Pagination
page = 2
per_page = 20
start = (page - 1) * per_page  # Calculate offset
users = User.objects.all()[start:start + per_page]  # LIMIT with OFFSET

# ═══════════════════════════════════════════════════
# 3. CHUNK LARGE DATASETS
# ═══════════════════════════════════════════════════

# Bad: Load all at once (memory issue)
users = User.objects.all()  # Loads everything into memory
for user in users:
    process(user)

# Good: Use iterator() for large datasets
users = User.objects.all().iterator(chunk_size=200)  # Process in chunks
# iterator() = fetch in batches, don't cache
for user in users:
    process(user)  # Process each user

# Or use custom chunking
def chunk_queryset(queryset, chunk_size=1000):
    """Process queryset in chunks"""
    count = queryset.count()  # Get total count
    for start in range(0, count, chunk_size):  # Loop in chunks
        chunk = queryset[start:start + chunk_size]  # Get chunk
        for item in chunk:
            yield item  # Yield each item

# Usage
for user in chunk_queryset(User.objects.all()):
    process(user)

# ═══════════════════════════════════════════════════
# 4. EAGER LOADING (Solve N+1 Problem)
# ═══════════════════════════════════════════════════

# Bad: N+1 queries
users = User.objects.all()  # 1 query
for user in users:
    print(user.profile.bio)  # N queries (one per user)
# Total: 1 + N queries

# Good: Use select_related for ForeignKey/OneToOne
users = User.objects.select_related('profile').all()  # 1 query with JOIN
for user in users:
    print(user.profile.bio)  # No additional queries
# Total: 1 query only

# Good: Use prefetch_related for ManyToMany/Reverse FK
posts = Post.objects.prefetch_related('tags').all()  # 2 queries
for post in posts:
    for tag in post.tags.all():  # No additional queries
        print(tag.name)
# Total: 2 queries (posts + tags)

# Multiple relations
posts = Post.objects.select_related('user').prefetch_related('tags')
# select_related for user (JOIN)
# prefetch_related for tags (separate query)

# ═══════════════════════════════════════════════════
# 5. USE EXISTS FOR CHECKING
# ═══════════════════════════════════════════════════

# Bad: Load all data to check
if User.objects.filter(email='test@example.com').count() > 0:  # Counts all
    pass

# Good: Use exists()
if User.objects.filter(email='test@example.com').exists():  # LIMIT 1
    pass
# exists() = more efficient, stops at first match

# ═══════════════════════════════════════════════════
# 6. BULK OPERATIONS
# ═══════════════════════════════════════════════════

# Bad: Individual inserts (N queries)
for i in range(1000):
    User.objects.create(name=f'User {i}')  # 1000 queries

# Good: Bulk create (1 query)
users = [User(name=f'User {i}') for i in range(1000)]  # Create list
User.objects.bulk_create(users)  # Single INSERT with 1000 rows

# Bulk update
users = User.objects.filter(active=True)
users.update(status='verified')  # Single UPDATE query
# update() = bulk update without loading objects

# ═══════════════════════════════════════════════════
# 7. DEFER HEAVY FIELDS
# ═══════════════════════════════════════════════════

# Defer large text fields
posts = Post.objects.defer('content')  # Load all except content
# content is loaded only when accessed

# Load everything except specific fields
posts = Post.objects.defer('content', 'metadata')
```

### SQL Query Analysis

```python
from django.db import connection  # Import database connection
from django.db import reset_queries  # Import query reset
import logging  # Import logging

# ═══════════════════════════════════════════════════
# DEBUG QUERIES (settings.DEBUG = True required)
# ═══════════════════════════════════════════════════

# Enable query logging in settings.py
LOGGING = {
    'version': 1,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
    },
    'loggers': {
        'django.db.backends': {  # Database logger
            'handlers': ['console'],
            'level': 'DEBUG',  # Show all queries
        },
    },
}

# ═══════════════════════════════════════════════════
# VIEW EXECUTED QUERIES
# ═══════════════════════════════════════════════════

from django.db import connection

# Reset query log
reset_queries()  # Clear previous queries

# Run your queries
users = User.objects.filter(active=True)
list(users)  # Force evaluation

# Get executed queries
queries = connection.queries  # List of all queries
for query in queries:
    print(f"SQL: {query['sql']}")  # Print SQL
    print(f"Time: {query['time']}")  # Print execution time

# Total queries count
print(f"Total queries: {len(connection.queries)}")

# ═══════════════════════════════════════════════════
# GET SQL WITHOUT EXECUTING
# ═══════════════════════════════════════════════════

# Get SQL and parameters
query = User.objects.filter(active=True)
print(query.query)  # Print SQL query
# Shows: SELECT * FROM users WHERE active = True

# With parameters
query = User.objects.filter(name='John', active=True)
print(str(query.query))  # Print full SQL

# ═══════════════════════════════════════════════════
# EXPLAIN QUERY (Django 2.1+)
# ═══════════════════════════════════════════════════

# Analyze query execution plan
users = User.objects.filter(active=True).explain()
print(users)  # Print EXPLAIN output
# Shows MySQL/PostgreSQL execution plan

# With options (PostgreSQL)
users = User.objects.filter(active=True).explain(
    verbose=True,  # Verbose output
    analyze=True   # Actually execute and show timing
)

# ═══════════════════════════════════════════════════
# CUSTOM QUERY PROFILER
# ═══════════════════════════════════════════════════

class QueryProfiler:
    """Context manager to profile queries"""
    
    def __enter__(self):
        reset_queries()  # Clear queries
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        queries = connection.queries  # Get queries
        total_time = sum(float(q['time']) for q in queries)  # Sum time
        
        print(f"\n{'='*50}")
        print(f"Total Queries: {len(queries)}")
        print(f"Total Time: {total_time:.4f}s")
        print(f"{'='*50}\n")
        
        for i, query in enumerate(queries, 1):
            print(f"{i}. {query['sql'][:100]}...")  # First 100 chars
            print(f"   Time: {query['time']}s\n")

# Usage
with QueryProfiler():
    users = User.objects.select_related('profile').all()
    for user in users:
        print(user.name)

# ═══════════════════════════════════════════════════
# DJANGO DEBUG TOOLBAR (Recommended)
# ═══════════════════════════════════════════════════

# Install: pip install django-debug-toolbar

# Add to INSTALLED_APPS
INSTALLED_APPS = [
    # ...
    'debug_toolbar',
]

# Add to MIDDLEWARE
MIDDLEWARE = [
    # ...
    'debug_toolbar.middleware.DebugToolbarMiddleware',
]

# Add to urls.py
from django.urls import include
urlpatterns = [
    # ...
    path('__debug__/', include('debug_toolbar.urls')),
]

# Configure
INTERNAL_IPS = ['127.0.0.1']
```

---

## 🔍 Database Schema Checks

### Column Existence Check

```python
from django.db import connection  # Import database connection

# ═══════════════════════════════════════════════════
# CHECK IF COLUMN EXISTS
# ═══════════════════════════════════════════════════

def column_exists(table_name, column_name):
    """
    Check if column exists in table
    
    Args:
        table_name (str): Name of the table
        column_name (str): Name of the column
        
    Returns:
        bool: True if column exists, False otherwise
    """
    with connection.cursor() as cursor:  # Get database cursor
        cursor.execute("""
            SELECT COUNT(*)
            FROM information_schema.columns
            WHERE table_schema = DATABASE()
            AND table_name = %s
            AND column_name = %s
        """, [table_name, column_name])  # Execute with parameters
        
        result = cursor.fetchone()  # Get first row
        return result[0] > 0  # Return True if found

# Usage
if column_exists('orders', 'due_payment'):  # Check if column exists
    print("Column exists")
else:
    print("Column does not exist")

# ═══════════════════════════════════════════════════
# SAFE QUERY WITH COLUMN CHECK
# ═══════════════════════════════════════════════════

# Use in query building
from django.db.models import Value, F
from django.db.models.functions import Coalesce

def build_safe_query():
    """Build query that checks column existence"""
    query = Order.objects.all()  # Base query
    
    # Check if column exists before using
    if column_exists('orders', 'due_payment'):
        query = query.annotate(
            due_amount=Coalesce(F('due_payment'), Value(0))  # Use column
        )
    else:
        query = query.annotate(
            due_amount=Value(0)  # Use default
        )
    
    return query

# ═══════════════════════════════════════════════════
# DYNAMIC FIELD ACCESS
# ═══════════════════════════════════════════════════

def get_field_value(instance, field_name, default=None):
    """
    Safely get field value from model instance
    
    Args:
        instance: Model instance
        field_name (str): Name of field
        default: Default value if field doesn't exist
        
    Returns:
        Field value or default
    """
    if hasattr(instance, field_name):  # Check if attribute exists
        return getattr(instance, field_name)  # Get value
    return default  # Return default

# Usage
order = Order.objects.first()
due_payment = get_field_value(order, 'due_payment', 0)
```

### Schema Information Queries

```python
from django.db import connection  # Import database connection

# ═══════════════════════════════════════════════════
# GET TABLE COLUMNS
# ═══════════════════════════════════════════════════

def get_table_columns(table_name):
    """
    Get all columns for a table
    
    Args:
        table_name (str): Name of the table
        
    Returns:
        list: List of column info dicts
    """
    with connection.cursor() as cursor:
        cursor.execute("""
            SELECT 
                column_name,
                data_type,
                column_default,
                is_nullable,
                character_maximum_length
            FROM information_schema.columns
            WHERE table_schema = DATABASE()
            AND table_name = %s
            ORDER BY ordinal_position
        """, [table_name])
        
        columns = cursor.fetchall()  # Get all rows
        
        # Convert to list of dicts
        result = []
        for col in columns:
            result.append({
                'name': col[0],
                'type': col[1],
                'default': col[2],
                'nullable': col[3] == 'YES',
                'max_length': col[4]
            })
        
        return result

# Usage
columns = get_table_columns('users')
for col in columns:
    print(f"{col['name']}: {col['type']}")

# ═══════════════════════════════════════════════════
# CHECK IF TABLE EXISTS
# ═══════════════════════════════════════════════════

def table_exists(table_name):
    """Check if table exists in database"""
    with connection.cursor() as cursor:
        cursor.execute("""
            SELECT COUNT(*)
            FROM information_schema.tables
            WHERE table_schema = DATABASE()
            AND table_name = %s
        """, [table_name])
        
        result = cursor.fetchone()
        return result[0] > 0

# Usage
if table_exists('orders'):
    print("Table exists")

# ═══════════════════════════════════════════════════
# GET TABLE INDEXES
# ═══════════════════════════════════════════════════

def get_table_indexes(table_name):
    """Get all indexes for a table"""
    with connection.cursor() as cursor:
        cursor.execute("""
            SELECT 
                index_name,
                column_name,
                non_unique
            FROM information_schema.statistics
            WHERE table_schema = DATABASE()
            AND table_name = %s
            ORDER BY index_name, seq_in_index
        """, [table_name])
        
        return cursor.fetchall()

# ═══════════════════════════════════════════════════
# GET FOREIGN KEYS
# ═══════════════════════════════════════════════════

def get_foreign_keys(table_name):
    """Get all foreign keys for a table"""
    with connection.cursor() as cursor:
        cursor.execute("""
            SELECT 
                column_name,
                referenced_table_name,
                referenced_column_name
            FROM information_schema.key_column_usage
            WHERE table_schema = DATABASE()
            AND table_name = %s
            AND referenced_table_name IS NOT NULL
        """, [table_name])
        
        return cursor.fetchall()

# ═══════════════════════════════════════════════════
# GET DATABASE INTROSPECTION (Django way)
# ═══════════════════════════════════════════════════

from django.db import connection

# Get table description
with connection.cursor() as cursor:
    cursor.execute("DESCRIBE users")  # MySQL
    # or cursor.execute("SELECT * FROM users LIMIT 0")  # Generic
    description = cursor.description
    
    for field in description:
        print(f"Column: {field[0]}, Type: {field[1]}")

# Get all tables
from django.db import connection

with connection.cursor() as cursor:
    cursor.execute("SHOW TABLES")  # MySQL
    tables = cursor.fetchall()
    for table in tables:
        print(table[0])
```

---

## 🎨 Common Patterns

### CSV Export Pattern

```python
import csv  # Import CSV module
from django.http import HttpResponse  # Import HTTP response
from io import StringIO  # Import string buffer

# ═══════════════════════════════════════════════════
# CSV EXPORT FUNCTION
# ═══════════════════════════════════════════════════

def export_to_csv(queryset, filename='export.csv', fields=None):
    """
    Export queryset to CSV
    
    Args:
        queryset: Django queryset to export
        filename (str): Name of CSV file
        fields (list): List of field names to export
        
    Returns:
        HttpResponse: CSV file response
    """
    # Create HTTP response with CSV content type
    response = HttpResponse(content_type='text/csv')  # Set content type
    response['Content-Disposition'] = f'attachment; filename="{filename}"'  # Set filename
    
    # Create CSV writer
    writer = csv.writer(response)  # Create writer for response
    
    # Get model fields if not specified
    if not fields:
        model = queryset.model  # Get model class
        fields = [field.name for field in model._meta.fields]  # Get all field names
    
    # Write header row
    writer.writerow(fields)  # Write field names as header
    
    # Write data rows
    for obj in queryset:  # Loop through objects
        row = [getattr(obj, field, '') for field in fields]  # Get field values
        writer.writerow(row)  # Write row
    
    return response  # Return response

# Usage in view
def export_users_csv(request):
    users = User.objects.all()  # Get users
    return export_to_csv(
        users,
        filename='users.csv',
        fields=['id', 'name', 'email', 'created_at']
    )

# ═══════════════════════════════════════════════════
# CSV EXPORT WITH CUSTOM FORMATTING
# ═══════════════════════════════════════════════════

def export_orders_csv(queryset):
    """Export orders with custom formatting"""
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = 'attachment; filename="orders.csv"'
    
    writer = csv.writer(response)
    
    # Custom headers
    writer.writerow([
        'Order ID',
        'Customer',
        'Amount',
        'Status',
        'Date'
    ])
    
    # Write data with custom formatting
    for order in queryset:
        writer.writerow([
            order.id,
            order.customer.name if order.customer else 'N/A',  # Handle null
            f'${order.amount:.2f}',  # Format currency
            order.get_status_display(),  # Get choice display
            order.created_at.strftime('%Y-%m-%d')  # Format date
        ])
    
    return response

# ═══════════════════════════════════════════════════
# CSV STRING (not file download)
# ═══════════════════════════════════════════════════

def generate_csv_string(data):
    """Generate CSV string from data"""
    output = StringIO()  # Create string buffer
    writer = csv.writer(output)  # Create writer
    
    # Write headers
    writer.writerow(['Column1', 'Column2', 'Column3'])
    
    # Write data
    for row in data:
        writer.writerow([
            row.get('column1', ''),  # Use .get() for safe access
            row.get('column2', ''),
            row.get('column3', '')
        ])
    
    csv_string = output.getvalue()  # Get CSV string
    output.close()  # Close buffer
    
    return csv_string
```

### Null Handling Patterns

```python
from django.db.models.functions import Coalesce  # Import Coalesce
from django.db.models import Value, F  # Import Value and F

# ═══════════════════════════════════════════════════
# PYTHON NULL COALESCING
# ═══════════════════════════════════════════════════

# Simple default value
value = row.column or 'default_value'  # Use or for truthy check
value = row.column if row.column is not None else 'default'  # Explicit None check

# Multiple fallbacks
value = row.column1 or row.column2 or row.column3 or 'default'

# Safe attribute access
value = getattr(row, 'column', 'default_value')  # getattr with default

# ═══════════════════════════════════════════════════
# SQL COALESCE IN QUERIES
# ═══════════════════════════════════════════════════

# Single column default
orders = Order.objects.annotate(
    safe_amount=Coalesce('amount', Value(0))  # Return amount or 0
)
# Coalesce = return first non-null value

# Multiple fallbacks
orders = Order.objects.annotate(
    payment_amount=Coalesce(
        'paid_amount',      # Try first
        'total_amount',     # Then second
        'estimated_amount', # Then third
        Value(0)            # Finally default
    )
)

# With field references
users = User.objects.annotate(
    display_name=Coalesce(
        'nickname',         # Preferred name
        'full_name',        # Full name
        'email',            # Email as fallback
        Value('Anonymous')  # Default
    )
)

# ═══════════════════════════════════════════════════
# NULL-SAFE COMPARISONS
# ═══════════════════════════════════════════════════

# Filter with null handling
orders = Order.objects.annotate(
    safe_status=Coalesce('status', Value('pending'))
).filter(safe_status='active')

# Compare with null safety
products = Product.objects.annotate(
    effective_price=Coalesce('sale_price', 'regular_price', Value(0))
).filter(effective_price__gt=100)
```

### Dynamic Column Selection

```python
# ═══════════════════════════════════════════════════
# STANDARD COLUMNS PATTERN
# ═══════════════════════════════════════════════════

class OrderExport:
    """Order export with standard columns"""
    
    # Define standard columns
    STANDARD_COLUMNS = [
        'id',
        'order_ref_id',
        'sold_by',
        'provider_name',
        'package_name',
        'payment_method',
        'commission',
        'total_amount',
        'created_at'
    ]
    
    @classmethod
    def get_columns(cls):
        """Get standard column list"""
        return cls.STANDARD_COLUMNS
    
    @classmethod
    def get_data(cls, queryset):
        """Get data using standard columns"""
        return queryset.values(*cls.STANDARD_COLUMNS)  # Select only these columns
    
    @classmethod
    def format_row(cls, order):
        """Format single order using standard columns"""
        return [
            getattr(order, col, '')  # Get each column value
            for col in cls.STANDARD_COLUMNS  # For each standard column
        ]

# Usage
columns = OrderExport.get_columns()
data = OrderExport.get_data(Order.objects.all())

# ═══════════════════════════════════════════════════
# DYNAMIC FIELD ACCESS
# ═══════════════════════════════════════════════════

def extract_fields(instance, field_names):
    """
    Extract field values from instance
    
    Args:
        instance: Model instance
        field_names (list): List of field names
        
    Returns:
        dict: Dictionary of field values
    """
    result = {}
    for field in field_names:
        # Handle nested fields with __
        if '__' in field:  # If nested field
            parts = field.split('__')  # Split by __
            value = instance
            for part in parts:  # Traverse relationships
                value = getattr(value, part, None)
                if value is None:
                    break
            result[field] = value
        else:
            result[field] = getattr(instance, field, None)  # Get direct field
    
    return result

# Usage
fields = ['id', 'name', 'user__email', 'category__name']
data = extract_fields(order, fields)

# ═══════════════════════════════════════════════════
# CONFIGURABLE EXPORTS
# ═══════════════════════════════════════════════════

class ConfigurableExport:
    """Export with configurable columns"""
    
    # Available columns configuration
    AVAILABLE_COLUMNS = {
        'id': {'label': 'Order ID', 'field': 'id'},
        'customer': {'label': 'Customer Name', 'field': 'customer__name'},
        'amount': {'label': 'Amount', 'field': 'amount', 'format': 'currency'},
        'date': {'label': 'Date', 'field': 'created_at', 'format': 'date'},
        'status': {'label': 'Status', 'field': 'status', 'format': 'choice'},
    }
    
    @classmethod
    def export(cls, queryset, selected_columns):
        """
        Export with selected columns
        
        Args:
            queryset: Queryset to export
            selected_columns (list): List of column keys to include
            
        Returns:
            list: Formatted data
        """
        # Get field names
        fields = [
            cls.AVAILABLE_COLUMNS[col]['field']
            for col in selected_columns
        ]
        
        # Get data
        data = queryset.values(*fields)
        
        # Format data
        formatted = []
        for row in data:
            formatted_row = {}
            for col in selected_columns:
                config = cls.AVAILABLE_COLUMNS[col]
                value = row.get(config['field'])
                
                # Apply formatting
                if config.get('format') == 'currency':
                    value = f'${value:.2f}'
                elif config.get('format') == 'date':
                    value = value.strftime('%Y-%m-%d') if value else ''
                
                formatted_row[config['label']] = value
            
            formatted.append(formatted_row)
        
        return formatted

# Usage
selected = ['id', 'customer', 'amount', 'date']
export_data = ConfigurableExport.export(Order.objects.all(), selected)
```

---

## 🛠️ Debugging & Testing

### Query Debugging

```python
import logging  # Import logging
from django.conf import settings  # Import settings
from django.db import connection, reset_queries  # Import connection tools

# ═══════════════════════════════════════════════════
# ENABLE QUERY LOGGING
# ═══════════════════════════════════════════════════

# In settings.py
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {  # Console handler
            'class': 'logging.StreamHandler',
        },
    },
    'loggers': {
        'django.db.backends': {  # Database backend logger
            'handlers': ['console'],
            'level': 'DEBUG',  # Log all SQL queries
            'propagate': False,
        },
    },
}

# ═══════════════════════════════════════════════════
# VIEW EXECUTED QUERIES
# ═══════════════════════════════════════════════════

# Enable query logging (requires DEBUG=True)
settings.DEBUG = True

# Clear previous queries
reset_queries()

# Run your code
users = User.objects.filter(active=True)
list(users)  # Force evaluation

# Print all executed queries
from django.db import connection
for query in connection.queries:
    print(query['sql'])  # Print SQL
    print(query['time'])  # Print time in seconds

# Total time
total_time = sum(float(q['time']) for q in connection.queries)
print(f"Total time: {total_time}s")

# ═══════════════════════════════════════════════════
# QUERY DEBUGGER DECORATOR
# ═══════════════════════════════════════════════════

from functools import wraps
from django.db import connection, reset_queries

def debug_queries(func):
    """Decorator to debug queries in a function"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        reset_queries()  # Clear queries
        
        result = func(*args, **kwargs)  # Call function
        
        # Print query stats
        queries = connection.queries
        print(f"\n{'='*50}")
        print(f"Function: {func.__name__}")
        print(f"Total Queries: {len(queries)}")
        print(f"Total Time: {sum(float(q['time']) for q in queries):.4f}s")
        print(f"{'='*50}\n")
        
        for i, query in enumerate(queries, 1):
            print(f"{i}. {query['sql']}")
            print(f"   Time: {query['time']}s\n")
        
        return result
    
    return wrapper

# Usage
@debug_queries
def get_user_data():
    users = User.objects.select_related('profile').all()
    return list(users)

# ═══════════════════════════════════════════════════
# CONTEXT MANAGER FOR QUERY DEBUGGING
# ═══════════════════════════════════════════════════

class QueryDebugger:
    """Context manager for query debugging"""
    
    def __enter__(self):
        reset_queries()  # Clear queries
        self.initial_queries = len(connection.queries)  # Get initial count
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        queries = connection.queries[self.initial_queries:]  # Get new queries
        
        print(f"\nQueries executed: {len(queries)}")
        print(f"Total time: {sum(float(q['time']) for q in queries):.4f}s\n")
        
        for i, query in enumerate(queries, 1):
            print(f"{i}. {query['sql'][:100]}...")  # First 100 chars
            print(f"   Time: {query['time']}s\n")

# Usage
with QueryDebugger():
    users = User.objects.select_related('profile').all()
    for user in users:
        print(user.name)
```

### Raw SQL Execution

```python
from django.db import connection  # Import connection

# ═══════════════════════════════════════════════════
# EXECUTE RAW SELECT
# ═══════════════════════════════════════════════════

# Method 1: Using cursor
from django.db import connection

def execute_raw_select(sql, params=None):
    """Execute raw SELECT query"""
    with connection.cursor() as cursor:  # Get cursor
        cursor.execute(sql, params or [])  # Execute query
        columns = [col[0] for col in cursor.description]  # Get column names
        results = [
            dict(zip(columns, row))  # Create dict for each row
            for row in cursor.fetchall()  # Fetch all rows
        ]
    return results

# Usage
users = execute_raw_select(
    'SELECT * FROM users WHERE id = %s',  # SQL
    [1]  # Parameters
)

# Method 2: Using raw() for model instances
users = User.objects.raw('SELECT * FROM users WHERE active = %s', [True])
# Returns model instances

# Iterate results
for user in users:
    print(user.name)  # Access as model instance

# ═══════════════════════════════════════════════════
# EXECUTE RAW INSERT
# ═══════════════════════════════════════════════════

def execute_raw_insert(table, data):
    """Execute raw INSERT"""
    columns = ', '.join(data.keys())  # Column names
    placeholders = ', '.join(['%s'] * len(data))  # Placeholders
    sql = f'INSERT INTO {table} ({columns}) VALUES ({placeholders})'
    
    with connection.cursor() as cursor:
        cursor.execute(sql, list(data.values()))  # Execute
        return cursor.lastrowid  # Return inserted ID

# Usage
user_id = execute_raw_insert('users', {
    'name': 'John',
    'email': 'john@example.com'
})

# ═══════════════════════════════════════════════════
# EXECUTE RAW UPDATE
# ═══════════════════════════════════════════════════

def execute_raw_update(table, data, where, where_params):
    """Execute raw UPDATE"""
    set_clause = ', '.join([f'{k} = %s' for k in data.keys()])
    sql = f'UPDATE {table} SET {set_clause} WHERE {where}'
    
    with connection.cursor() as cursor:
        params = list(data.values()) + where_params
        cursor.execute(sql, params)
        return cursor.rowcount  # Return affected rows

# Usage
rows_updated = execute_raw_update(
    'users',
    {'name': 'Jane'},  # Data to update
    'id = %s',  # WHERE clause
    [1]  # WHERE parameters
)

# ═══════════════════════════════════════════════════
# EXECUTE RAW DELETE
# ═══════════════════════════════════════════════════

def execute_raw_delete(table, where, params):
    """Execute raw DELETE"""
    sql = f'DELETE FROM {table} WHERE {where}'
    
    with connection.cursor() as cursor:
        cursor.execute(sql, params)
        return cursor.rowcount

# Usage
rows_deleted = execute_raw_delete('users', 'id = %s', [1])
```

### Transaction Handling

```python
from django.db import transaction  # Import transaction

# ═══════════════════════════════════════════════════
# ATOMIC DECORATOR
# ═══════════════════════════════════════════════════

@transaction.atomic  # Wrap function in transaction
def create_order(user, items):
    """Create order with items (all or nothing)"""
    # Create order
    order = Order.objects.create(user=user)  # Create order
    
    # Create order items
    for item in items:
        OrderItem.objects.create(  # Create item
            order=order,
            product=item['product'],
            quantity=item['quantity']
        )
    
    # Update stock
    for item in items:
        product = item['product']
        product.stock -= item['quantity']
        product.save()
    
    return order
# If any operation fails, all are rolled back

# ═══════════════════════════════════════════════════
# ATOMIC CONTEXT MANAGER
# ═══════════════════════════════════════════════════

def process_payment(order):
    """Process payment with transaction"""
    try:
        with transaction.atomic():  # Start transaction
            # Charge payment
            payment = Payment.objects.create(
                order=order,
                amount=order.total
            )
            
            # Update order status
            order.status = 'paid'
            order.save()
            
            # Send confirmation
            send_confirmation_email(order)
            
    except Exception as e:
        # Transaction automatically rolled back
        print(f"Payment failed: {e}")
        raise

# ═══════════════════════════════════════════════════
# MANUAL TRANSACTION CONTROL
# ═══════════════════════════════════════════════════

from django.db import transaction, connection

def manual_transaction():
    """Manual transaction control"""
    # Start transaction
    transaction.set_autocommit(False)
    
    try:
        # Do operations
        user = User.objects.create(name='John')
        profile = Profile.objects.create(user=user)
        
        # Commit transaction
        transaction.commit()
        
    except Exception as e:
        # Rollback on error
        transaction.rollback()
        print(f"Transaction failed: {e}")
        raise
    
    finally:
        # Restore autocommit
        transaction.set_autocommit(True)

# ═══════════════════════════════════════════════════
# SAVEPOINTS (Nested Transactions)
# ═══════════════════════════════════════════════════

def nested_transactions():
    """Example of savepoints"""
    with transaction.atomic():  # Outer transaction
        user = User.objects.create(name='John')
        
        try:
            with transaction.atomic():  # Inner transaction (savepoint)
                profile = Profile.objects.create(user=user)
                # This might fail
                raise ValueError("Profile creation failed")
        except ValueError:
            # Inner transaction rolled back
            # But outer transaction continues
            pass
        
        # User is still created
        return user

# ═══════════════════════════════════════════════════
# SELECT FOR UPDATE (Locking)
# ═══════════════════════════════════════════════════

def update_stock_safely(product_id, quantity):
    """Update stock with row locking"""
    with transaction.atomic():
        # Lock row for update
        product = Product.objects.select_for_update().get(id=product_id)
        # select_for_update() = SELECT ... FOR UPDATE
        # Prevents other transactions from modifying
        
        # Check stock
        if product.stock >= quantity:
            product.stock -= quantity
            product.save()
            return True
        
        return False
```

---

## 💡 Pro Tips

1. **Always use parameterized queries** to prevent SQL injection
   ```python
   # Bad
   User.objects.raw(f"SELECT * FROM users WHERE name = '{name}'")
   
   # Good
   User.objects.raw("SELECT * FROM users WHERE name = %s", [name])
   ```

2. **Use Coalesce for NULL handling**
   ```python
   Order.objects.annotate(
       safe_amount=Coalesce('amount', Value(0))
   )
   ```

3. **Use select_related and prefetch_related** to avoid N+1 queries
   ```python
   # ForeignKey/OneToOne
   posts = Post.objects.select_related('user')
   
   # ManyToMany/Reverse FK
   posts = Post.objects.prefetch_related('tags')
   ```

4. **Check column existence** before using dynamic fields
   ```python
   if column_exists('table_name', 'column_name'):
       query = query.annotate(field=F('column_name'))
   ```

5. **Use union() for combining similar datasets**
   ```python
   result = query1.union(query2, query3)
   ```

6. **Index frequently queried columns**
   ```python
   class Meta:
       indexes = [
           models.Index(fields=['status', 'created_at']),
       ]
   ```

7. **Use iterator() for large datasets**
   ```python
   for user in User.objects.all().iterator(chunk_size=1000):
       process(user)
   ```

8. **Use annotate() for calculations in database**
   ```python
   orders = Order.objects.annotate(
       total=F('price') * F('quantity')
   )
   ```

9. **Use bulk operations for multiple records**
   ```python
   User.objects.bulk_create([user1, user2, user3])
   ```

10. **Use explain() to analyze query performance**
    ```python
    print(User.objects.filter(active=True).explain())
    ```

---

## 🎯 Quick Reference Commands

```bash
# Django Management Commands
python manage.py makemigrations  # Create migrations
python manage.py migrate  # Apply migrations
python manage.py dbshell  # Open database shell
python manage.py shell  # Open Django shell
python manage.py showmigrations  # Show migration status
python manage.py sqlmigrate app_name migration_name  # Show SQL for migration

# Database Commands (PostgreSQL)
\dt  # List tables
\d table_name  # Describe table
\di  # List indexes

# Database Commands (MySQL)
SHOW TABLES;
DESCRIBE table_name;
SHOW INDEX FROM table_name;
EXPLAIN SELECT * FROM table_name WHERE condition;
```

---

## 🔄 Laravel to Django Quick Reference

| Laravel | Django | Purpose |
|---------|---------|---------|
| `DB::table('users')->get()` | `User.objects.all()` | Get all records |
| `->where('name', 'John')` | `.filter(name='John')` | Filter records |
| `->first()` | `.first()` | Get first record |
| `->find(1)` | `.get(pk=1)` | Get by ID |
| `->select('name', 'email')` | `.values('name', 'email')` | Select columns |
| `->join()` | `.select_related()` | Join tables |
| `->with()` | `.select_related()` / `.prefetch_related()` | Eager loading |
| `->count()` | `.count()` | Count records |
| `->sum('amount')` | `.aggregate(Sum('amount'))` | Sum values |
| `->groupBy()` | `.values().annotate()` | Group by |
| `->orderBy()` | `.order_by()` | Order results |
| `->limit()` | `[:n]` | Limit results |
| `->union()` | `.union()` | Union queries |
| `DB::raw()` | `.extra()` or `.annotate()` | Raw SQL |
| `->whereRaw()` | `.extra(where=[...])` | Raw WHERE |
| `->create()` | `.create()` | Create record |
| `->update()` | `.update()` | Update records |
| `->delete()` | `.delete()` | Delete records |

---

*Master these patterns and you'll be a Django ORM expert! 🚀*
